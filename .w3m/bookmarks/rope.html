<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Rope Overview</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="rope-overview">
<h1 class="title">Rope Overview</h1>

<p>The purpose of this file is to give an overview of some of rope's
features.  It is incomplete.  And some of the features shown here are
old and do not show what rope can do in extremes.  So if you really
want to feel the power of rope try its features and see its unit
tests.</p>
<p>This file is more suitable for the users.  Developers who plan to use
rope as a library might find <a class="reference external" href="library.html">library.txt</a> more useful.</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#ropeproject-folder" id="id1"><tt class="docutils literal"><span class="pre">.ropeproject</span></tt> Folder</a></li>
<li><a class="reference internal" href="#refactorings" id="id2">Refactorings</a><ul>
<li><a class="reference internal" href="#renaming-attributes" id="id3">Renaming Attributes</a></li>
<li><a class="reference internal" href="#renaming-function-keyword-parameters" id="id4">Renaming Function Keyword Parameters</a></li>
<li><a class="reference internal" href="#renaming-modules" id="id5">Renaming modules</a></li>
<li><a class="reference internal" href="#renaming-occurrences-in-strings-and-comments" id="id6">Renaming Occurrences In Strings And Comments</a></li>
<li><a class="reference internal" href="#rename-when-unsure" id="id7">Rename When Unsure</a></li>
<li><a class="reference internal" href="#move-method-refactoring" id="id8">Move Method Refactoring</a></li>
<li><a class="reference internal" href="#moving-fields" id="id9">Moving Fields</a></li>
<li><a class="reference internal" href="#extract-method" id="id10">Extract Method</a></li>
<li><a class="reference internal" href="#extracting-similar-expressions-statements" id="id11">Extracting Similar Expressions/Statements</a></li>
<li><a class="reference internal" href="#extract-method-in-staticmethods-classmethods" id="id12">Extract Method In staticmethods/classmethods</a></li>
<li><a class="reference internal" href="#inline-method-refactoring" id="id13">Inline Method Refactoring</a></li>
<li><a class="reference internal" href="#inlining-parameters" id="id14">Inlining Parameters</a></li>
<li><a class="reference internal" href="#use-function-refactoring" id="id15">Use Function Refactoring</a></li>
<li><a class="reference internal" href="#automatic-default-insertion-in-change-signature" id="id16">Automatic Default Insertion In Change Signature</a></li>
<li><a class="reference internal" href="#sorting-imports" id="id17">Sorting Imports</a></li>
<li><a class="reference internal" href="#handling-long-imports" id="id18">Handling Long Imports</a></li>
<li><a class="reference internal" href="#stoppable-refactorings" id="id19">Stoppable Refactorings</a></li>
<li><a class="reference internal" href="#basic-implicit-interfaces" id="id20">Basic Implicit Interfaces</a></li>
<li><a class="reference internal" href="#restructurings" id="id21">Restructurings</a><ul>
<li><a class="reference internal" href="#example-1" id="id22">Example 1</a></li>
<li><a class="reference internal" href="#example-2" id="id23">Example 2</a></li>
<li><a class="reference internal" href="#example-3" id="id24">Example 3</a></li>
<li><a class="reference internal" href="#issues" id="id25">Issues</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#object-inference" id="id26">Object Inference</a><ul>
<li><a class="reference internal" href="#static-object-inference" id="id27">Static Object Inference</a></li>
<li><a class="reference internal" href="#dynamic-object-analysis" id="id28">Dynamic Object Analysis</a><ul>
<li><a class="reference internal" href="#builtin-container-types" id="id29">Builtin Container Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#guessing-function-returned-value-based-on-parameters" id="id30">Guessing Function Returned Value Based On Parameters</a></li>
<li><a class="reference internal" href="#automatic-soa" id="id31">Automatic SOA</a></li>
<li><a class="reference internal" href="#validating-object-db" id="id32">Validating Object DB</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-source-folders" id="id33">Custom Source Folders</a></li>
<li><a class="reference internal" href="#version-control-systems-support" id="id34">Version Control Systems Support</a></li>
</ul>
</div>
<div class="section" id="ropeproject-folder">
<a class="toc-backref" href="#id1"><tt class="docutils literal"><span class="pre">.ropeproject</span></tt> Folder</a>
<p>Rope uses a folder inside projects for holding project configuration
and data.  Its default name is <tt class="docutils literal"><span class="pre">.ropeproject</span></tt>, but it can be
changed (you can even tell rope not to create this folder).</p>
<p>Currently it is used for things such as:</p>
<ul class="simple">
<li>There is a <tt class="docutils literal"><span class="pre">config.py</span></tt> file in this folder in which you can change
project configurations.  Have look at the default <tt class="docutils literal"><span class="pre">config.py</span></tt> file
(is created when it does not exist) for more information.</li>
<li>It can be used for saving project history, so that the next time you
open the project you can undo past changes.</li>
<li>It can be used for saving object information to help rope object
inference.</li>
<li>It can be used for saving global names cache which is used in
auto-import.</li>
</ul>
<p>You can change what to save and what not to in the <tt class="docutils literal"><span class="pre">config.py</span></tt> file.</p>
</div>
<div class="section" id="refactorings">
<a class="toc-backref" href="#id2">Refactorings</a>
<p>This section shows some random refactorings that you can perform using
rope.</p>
<div class="section" id="renaming-attributes">
<a class="toc-backref" href="#id3">Renaming Attributes</a>
<p>Consider we have:</p>
<pre class="literal-block">
class AClass(object):

    def __init__(self):
        self.an_attr = 1

    def a_method(self, arg):
        print self.an_attr, arg

a_var = AClass()
a_var.a_method(a_var.an_attr)
</pre>
<p>After renaming <tt class="docutils literal"><span class="pre">an_attr</span></tt> to <tt class="docutils literal"><span class="pre">new_attr</span></tt> and <tt class="docutils literal"><span class="pre">a_method</span></tt> to
<tt class="docutils literal"><span class="pre">new_method</span></tt> we'll have:</p>
<pre class="literal-block">
class AClass(object):

    def __init__(self):
        self.new_attr = 1

    def new_method(self, arg):
        print self.new_attr, arg

a_var = AClass()
a_var.new_method(a_var.new_attr)
</pre>
</div>
<div class="section" id="renaming-function-keyword-parameters">
<a class="toc-backref" href="#id4">Renaming Function Keyword Parameters</a>
<p>On:</p>
<pre class="literal-block">
def a_func(a_param):
    print a_param

a_func(a_param=10)
a_func(10)
</pre>
<p>performing rename refactoring on any occurrence of <tt class="docutils literal"><span class="pre">a_param</span></tt> will
result in:</p>
<pre class="literal-block">
def a_func(new_param):
    print new_param

a_func(new_param=10)
a_func(10)
</pre>
</div>
<div class="section" id="renaming-modules">
<a class="toc-backref" href="#id5">Renaming modules</a>
<p>Consider the project tree is something like:</p>
<pre class="literal-block">
root/
  mod1.py
  mod2.py
</pre>
<p><tt class="docutils literal"><span class="pre">mod1.py</span></tt> contains:</p>
<pre class="literal-block">
import mod2
from mod2 import AClass

mod2.a_func()
a_var = AClass()
</pre>
<p>After performing rename refactoring one of the <tt class="docutils literal"><span class="pre">mod2</span></tt> occurrences in
<cite>mod1</cite> we'll get:</p>
<pre class="literal-block">
import newmod
from newmod import AClass

newmod.a_func()
a_var = AClass()
</pre>
<p>and the new project tree would be:</p>
<pre class="literal-block">
root/
  mod1.py
  newmod.py
</pre>
</div>
<div class="section" id="renaming-occurrences-in-strings-and-comments">
<a class="toc-backref" href="#id6">Renaming Occurrences In Strings And Comments</a>
<p>You can tell rope to rename all occurrences of a name in comments and
strings.  This can be done by passing <tt class="docutils literal"><span class="pre">docs=True</span></tt> to
<cite>Rename.get_changes()</cite> method.  Rope renames names in comments and
strings only where the name is visible.  For example in:</p>
<pre class="literal-block">
def f():
    a_var = 1
    # INFO: I'm printing `a_var`
    print 'a_var = %s' % a_var

# f prints a_var
</pre>
<p>after we rename the <cite>a_var</cite> local variable in <cite>f()</cite> to <cite>new_var</cite> we
would get:</p>
<pre class="literal-block">
def f():
    new_var = 1
    # INFO: I'm printing `new_var`
    print 'new_var = %s' % new_var

# f prints a_var
</pre>
<p>This makes it safe to assume that this option does not perform wrong
renames most of the time.</p>
<p>This also changes occurrences inside evaluated strings:</p>
<pre class="literal-block">
def func():
    print 'func() called'

eval('func()')
</pre>
<p>After renaming <cite>func</cite> to <cite>newfunc</cite> we should have:</p>
<pre class="literal-block">
def newfunc():
    print 'newfunc() called'

eval('newfunc()')
</pre>
</div>
<div class="section" id="rename-when-unsure">
<a class="toc-backref" href="#id7">Rename When Unsure</a>
<p>This option tells rope to rename when it doesn't know whether it is an
exact match or not.  For example after renaming <cite>C.a_func</cite> when the
'rename when unsure' option is set in:</p>
<pre class="literal-block">
class C(object):

    def a_func(self):
        pass

def a_func(arg):
    arg.a_func()

C().a_func()
</pre>
<p>we would have:</p>
<pre class="literal-block">
class C(object):

    def new_func(self):
        pass

def a_func(arg):
    arg.new_func()

C().new_func()
</pre>
<p>Note that the global <cite>a_func</cite> was not renamed because we are sure that
it is not a match.  But when using this option there might be some
unexpected renames.  So only use this option when the name is almost
unique and is not defined in other places.</p>
</div>
<div class="section" id="move-method-refactoring">
<a class="toc-backref" href="#id8">Move Method Refactoring</a>
<p>It happens when you perform move refactoring on a method of a class.
In this refactoring, a method of a class is moved to the class of one
of its attributes.  The old method will call the new method.  If you
want to change all of the occurrences of the old method to use the new
method you can inline it afterwards.</p>
<p>For instance if you perform move method on <cite>a_method</cite> in:</p>
<pre class="literal-block">
class A(object):
    pass

class B(object):

    def __init__(self):
        self.attr = A()

    def a_method(self):
        pass

b = B()
b.a_method()
</pre>
<p>You will be asked for the destination field and the name of the new
method.  If you use <tt class="docutils literal"><span class="pre">attr</span></tt> and <tt class="docutils literal"><span class="pre">new_method</span></tt> in these fields
and press enter, you'll have:</p>
<pre class="literal-block">
class A(object):

    def new_method(self):
        pass

class B(object):

    def __init__(self):
        self.attr = A()

    def a_method(self):
        return self.attr.new_method()


b = B()
b.a_method()
</pre>
<p>Now if you want to change the occurrences of <cite>B.a_method()</cite> to use
<cite>A.new_method()</cite>, you can inline <cite>B.a_method()</cite>:</p>
<pre class="literal-block">
class A(object):

    def new_method(self):
        pass

class B(object):

    def __init__(self):
        self.attr = A()

b = B()
b.attr.new_method()
</pre>
</div>
<div class="section" id="moving-fields">
<a class="toc-backref" href="#id9">Moving Fields</a>
<p>Rope does not have a separate refactoring for moving fields.  Rope's
refactorings are very flexible, though.  You can use the rename
refactoring to move fields.  For instance:</p>
<pre class="literal-block">
class A(object):
    pass

class B(object):

    def __init__(self):
        self.a = A()
        self.attr = 1

b = B()
print(b.attr)
</pre>
<p>consider we want to move <cite>attr</cite> to <cite>A</cite>.  We can do that by renaming <cite>attr</cite>
to <cite>a.attr</cite>:</p>
<pre class="literal-block">
class A(object):
    pass

class B(object):

    def __init__(self):
        self.a = A()
        self.a.attr = 1

b = B()
print(b.a.attr)
</pre>
<p>You can move the definition of <cite>attr</cite> manually.</p>
</div>
<div class="section" id="extract-method">
<a class="toc-backref" href="#id10">Extract Method</a>
<p>In these examples <tt class="docutils literal"><span class="pre">${region_start}</span></tt> and <tt class="docutils literal"><span class="pre">${region_end}</span></tt> show the
selected region for extraction:</p>
<pre class="literal-block">
def a_func():
    a = 1
    b = 2 * a
    c = ${region_start}a * 2 + b * 3${region_end}
</pre>
<p>After performing extract method we'll have:</p>
<pre class="literal-block">
def a_func():
    a = 1
    b = 2 * a
    c = new_func(a, b)

def new_func(a, b):
    return a * 2 + b * 3
</pre>
<p>For multi-line extractions if we have:</p>
<pre class="literal-block">
def a_func():
    a = 1
    ${region_start}b = 2 * a
    c = a * 2 + b * 3${region_end}
    print b, c
</pre>
<p>After performing extract method we'll have:</p>
<pre class="literal-block">
def a_func():
    a = 1
    b, c = new_func(a)
    print b, c

def new_func(a):
    b = 2 * a
    c = a * 2 + b * 3
    return b, c
</pre>
</div>
<div class="section" id="extracting-similar-expressions-statements">
<a class="toc-backref" href="#id11">Extracting Similar Expressions/Statements</a>
<p>When performing extract method or local variable refactorings you can
tell rope to extract similar expressions/statements.  For instance
in:</p>
<pre class="literal-block">
if True:
    x = 2 * 3
else:
    x = 2 * 3 + 1
</pre>
<p>Extracting <tt class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></tt> will result in:</p>
<pre class="literal-block">
six = 2 * 3
if True:
    x = six
else:
    x = six + 1
</pre>
</div>
<div class="section" id="extract-method-in-staticmethods-classmethods">
<a class="toc-backref" href="#id12">Extract Method In staticmethods/classmethods</a>
<p>The extract method refactoring has been enhanced to handle static and
class methods better.  For instance in:</p>
<pre class="literal-block">
class A(object):

    &#64;staticmethod
    def f(a):
        b = a * 2
</pre>
<p>if you extract <tt class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">2</span></tt> as a method you'll get:</p>
<pre class="literal-block">
class A(object):

    &#64;staticmethod
    def f(a):
        b = A.twice(a)

    &#64;staticmethod
    def twice(a):
        return a * 2
</pre>
</div>
<div class="section" id="inline-method-refactoring">
<a class="toc-backref" href="#id13">Inline Method Refactoring</a>
<p>Inline method refactoring can add imports when necessary.  For
instance consider <tt class="docutils literal"><span class="pre">mod1.py</span></tt> is:</p>
<pre class="literal-block">
import sys


class C(object):
    pass

def do_something():
    print sys.version
    return C()
</pre>
<p>and <tt class="docutils literal"><span class="pre">mod2.py</span></tt> is:</p>
<pre class="literal-block">
import mod1


c = mod1.do_something()
</pre>
<p>After inlining <cite>do_something</cite>, <tt class="docutils literal"><span class="pre">mod2.py</span></tt> would be:</p>
<pre class="literal-block">
import mod1
import sys


print sys.version
c = mod1.C()
</pre>
<p>Rope can inline methods, too:</p>
<pre class="literal-block">
class C(object):

    var = 1

    def f(self, p):
        result = self.var + pn
        return result


c = C()
x = c.f(1)
</pre>
<p>After inlining <cite>C.f()</cite>, we'll have:</p>
<pre class="literal-block">
class C(object):

    var = 1

c = C()
result = c.var + pn
x = result
</pre>
<p>As another example we will inline a <cite>classmethod</cite>:</p>
<pre class="literal-block">
class C(object):
    &#64;classmethod
    def say_hello(cls, name):
        return 'Saying hello to %s from %s' % (name, cls.__name__)
hello = C.say_hello('Rope')
</pre>
<p>Inlining <cite>say_hello</cite> will result in:</p>
<pre class="literal-block">
class C(object):
    pass
hello = 'Saying hello to %s from %s' % ('Rope', C.__name__)
</pre>
</div>
<div class="section" id="inlining-parameters">
<a class="toc-backref" href="#id14">Inlining Parameters</a>
<p><cite>rope.refactor.inline.create_inline()</cite> creates an <cite>InlineParameter</cite>
object when performed on a parameter.  It passes the default value of
the parameter wherever its function is called without passing it.  For
instance in:</p>
<pre class="literal-block">
def f(p1=1, p2=1):
    pass

f(3)
f()
f(3, 4)
</pre>
<p>after inlining p2 parameter will have:</p>
<pre class="literal-block">
def f(p1=1, p2=1):
    pass

f(3, 2)
f(p2=2)
f(3, 4)
</pre>
</div>
<div class="section" id="use-function-refactoring">
<a class="toc-backref" href="#id15">Use Function Refactoring</a>
<p>It tries to find the places in which a function can be used and
changes the code to call it instead.  For instance if mod1 is:</p>
<pre class="literal-block">
def square(p):
    return p ** 2

my_var = 3 ** 2
</pre>
<p>and mod2 is:</p>
<pre class="literal-block">
another_var = 4 ** 2
</pre>
<p>if we perform &quot;use function&quot; on square function, mod1 will be:</p>
<pre class="literal-block">
def square(p):
    return p ** 2

my_var = square(3)
</pre>
<p>and mod2 will be:</p>
<pre class="literal-block">
import mod1
another_var = mod1.square(4)
</pre>
</div>
<div class="section" id="automatic-default-insertion-in-change-signature">
<a class="toc-backref" href="#id16">Automatic Default Insertion In Change Signature</a>
<p>The <cite>rope.refactor.change_signature.ArgumentReorderer</cite> signature
changer takes a parameter called <tt class="docutils literal"><span class="pre">autodef</span></tt>.  If not <cite>None</cite>, its
value is used whenever rope needs to insert a default for a parameter
(that happens when an argument without default is moved after another
that has a default value).  For instance in:</p>
<pre class="literal-block">
def f(p1, p2=2):
    pass
</pre>
<p>if we reorder using:</p>
<pre class="literal-block">
changers = [ArgumentReorderer([1, 0], autodef='1')]
</pre>
<p>will result in:</p>
<pre class="literal-block">
def f(p2=2, p1=1):
    pass
</pre>
</div>
<div class="section" id="sorting-imports">
<a class="toc-backref" href="#id17">Sorting Imports</a>
<p>Organize imports sorts imports, too.  It does that according to
<a class="reference external" href="http://www.python.org/dev/peps/pep-0008">PEP 8</a>:</p>
<pre class="literal-block">
[__future__ imports]

[standard imports]

[third-party imports]

[project imports]


[the rest of module]
</pre>
</div>
<div class="section" id="handling-long-imports">
<a class="toc-backref" href="#id18">Handling Long Imports</a>
<p><tt class="docutils literal"><span class="pre">Handle</span> <span class="pre">long</span> <span class="pre">imports</span></tt> command trys to make long imports look better by
transforming <tt class="docutils literal"><span class="pre">import</span> <span class="pre">pkg1.pkg2.pkg3.pkg4.mod1</span></tt> to <tt class="docutils literal"><span class="pre">from</span>
<span class="pre">pkg1.pkg2.pkg3.pkg4</span> <span class="pre">import</span> <span class="pre">mod1</span></tt>.  Long imports can be identified
either by having lots of dots or being very long.  The default
configuration considers imported modules with more than 2 dots or with
more than 27 characters to be long.</p>
</div>
<div class="section" id="stoppable-refactorings">
<a class="toc-backref" href="#id19">Stoppable Refactorings</a>
<p>Some refactorings might take a long time to finish (based on the size
of your project).  The <cite>get_changes()</cite> method of these refactorings
take a parameter called <cite>task_handle</cite>.  If you want to monitor or stop
these refactoring you can pass a <cite>rope.refactor.
taskhandle.TaskHandle</cite> to this method.  See <cite>rope.refactor.taskhandle</cite>
module for more information.</p>
</div>
<div class="section" id="basic-implicit-interfaces">
<a class="toc-backref" href="#id20">Basic Implicit Interfaces</a>
<p>Implicit interfaces are the interfaces that you don't explicitly
define; But you expect a group of classes to have some common
attributes.  These interfaces are very common in dynamic languages;
Since we only have implementation inheritance and not interface
inheritance.  For instance:</p>
<pre class="literal-block">
class A(object):

    def count(self):
        pass

class B(object):

    def count(self):
        pass

def count_for(arg):
    return arg.count()

count_for(A())
count_for(B())
</pre>
<p>Here we know that there is an implicit interface defined by the
function <cite>count_for</cite> that provides <cite>count()</cite>.  Here when we rename
<cite>A.count()</cite> we expect <cite>B.count()</cite> to be renamed, too.  Currently rope
supports a basic form of implicit interfaces.  When you try to rename
an attribute of a parameter, rope renames that attribute for all
objects that have been passed to that function in different call
sites.  That is renaming the occurrence of <cite>count</cite> in <cite>count_for</cite>
function to <cite>newcount</cite> will result in:</p>
<pre class="literal-block">
class A(object):

    def newcount(self):
        pass

class B(object):

    def newcount(self):
        pass

def count_for(arg):
    return arg.newcount()

count_for(A())
count_for(B())
</pre>
<p>This also works for change method signature.  Note that this feature
relies on rope's object analysis mechanisms to find out the parameters
that are passed to a function.</p>
</div>
<div class="section" id="restructurings">
<a class="toc-backref" href="#id21">Restructurings</a>
<p><cite>rope.refactor.restructure</cite> can be used for performing restructurings.
A restructuring is a program transformation; not as well defined as
other refactorings like rename.  In this section, we'll see some
examples.  After this example you might like to have a look at:</p>
<ul class="simple">
<li><cite>rope.refactor.restructure</cite> for more examples and features not
described here like adding imports to changed modules.</li>
<li><cite>rope.refactor.wildcards</cite> for an overview of the arguments the
default wildcard supports.</li>
</ul>
<p>Finally, restructurings can be improved in many ways (for instance
adding new wildcards).  You might like to discuss your ideas in the
mailing list.</p>
<div class="section" id="example-1">
<a class="toc-backref" href="#id22">Example 1</a>
<p>In its basic form we have a pattern and a goal.  Consider we were not
aware of the <tt class="docutils literal"><span class="pre">**</span></tt> operator and wrote our own</p>
<pre class="literal-block">
def pow(x, y):
    result = 1
    for i in range(y):
        result *= x
    return result

print pow(2, 3)
</pre>
<p>Now that we know <tt class="docutils literal"><span class="pre">**</span></tt> exists we want to use it wherever <cite>pow</cite> is
used (there might be hundreds of them!).  We can use a pattern like:</p>
<pre class="literal-block">
pattern: pow(${param1}, ${param2})
</pre>
<p>Goal can be something like:</p>
<pre class="literal-block">
goal: ${param1} ** ${param2}
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">${...}</span></tt> can be used to match expressions.  By default
every expression at that point will match.</p>
<p>You can use the matched names in goal and they will be replaced with
the string that was matched in each occurrence.  So the outcome of our
restructuring will be:</p>
<pre class="literal-block">
def pow(x, y):
    result = 1
    for i in range(y):
        result *= x
    return result

print 2 ** 3
</pre>
<p>It seems to be working but what if <cite>pow</cite> is imported in some module or
we have some other function defined in some other module that uses the
same name and we don't want to change it.  Wildcard arguments come to
rescue.  Wildcard arguments is a mapping; Its keys are wildcard names
that appear in the pattern (the names inside <tt class="docutils literal"><span class="pre">${...}</span></tt>).</p>
<p>The values are the parameters that are passed to wildcard matchers.
The arguments a wildcard takes is based on its type.</p>
<p>For checking the type of a wildcard, we can pass <tt class="docutils literal"><span class="pre">type=value</span></tt> as an
argument; <tt class="docutils literal"><span class="pre">value</span></tt> should be resolved to a python variable (or
reference).  For instance for specifying <cite>pow</cite> in this example we can
use <cite>mod.pow</cite>.  As you see, this string should start from module name.
For referencing python builtin types and functions you can use
<cite>__builtin__</cite> module (for instance <cite>__builtin__.int</cite>).</p>
<p>For solving the mentioned problem, we change our <cite>pattern</cite>.  But
<cite>goal</cite> remains the same:</p>
<pre class="literal-block">
pattern: ${pow_func}(${param1}, ${param2})
goal: ${param1} ** ${param2}
</pre>
<p>Consider the name of the module containing our <cite>pow</cite> function is
<cite>mod</cite>.  <tt class="docutils literal"><span class="pre">args</span></tt> can be:</p>
<pre class="literal-block">
pow_func: name=mod.pow
</pre>
<p>If we need to pass more arguments to a wildcard matcher we can use
<tt class="docutils literal"><span class="pre">,</span></tt> to separate them.  Such as <tt class="docutils literal"><span class="pre">name:</span> <span class="pre">type=mod.MyClass,exact</span></tt>.</p>
<p>This restructuring handles aliases; like in:</p>
<pre class="literal-block">
mypow = pow
result = mypow(2, 3)
</pre>
<p>Transforms into:</p>
<pre class="literal-block">
mypow = pow
result = 2 ** 3
</pre>
<p>If we want to ignore aliases we can pass <tt class="docutils literal"><span class="pre">exact</span></tt> as another wildcard
argument:</p>
<pre class="literal-block">
pattern: ${pow}(${param1}, ${param2})
goal: ${param1} ** ${param2}
args: pow: name=mod.pow, exact
</pre>
<p><tt class="docutils literal"><span class="pre">${name}</span></tt>, by default, matches every expression at that point; if
<tt class="docutils literal"><span class="pre">exact</span></tt> argument is passed to a wildcard only the specified name
will match (for instance, if <tt class="docutils literal"><span class="pre">exact</span></tt> is specified , <tt class="docutils literal"><span class="pre">${name}</span></tt>
matches <tt class="docutils literal"><span class="pre">name</span></tt> and <tt class="docutils literal"><span class="pre">x.name</span></tt> but not <tt class="docutils literal"><span class="pre">var</span></tt> nor <tt class="docutils literal"><span class="pre">(1</span> <span class="pre">+</span> <span class="pre">2)</span></tt> while
a normal <tt class="docutils literal"><span class="pre">${name}</span></tt> can match all of them).</p>
<p>For performing this refactoring using rope library see <a class="reference external" href="library.html">library.txt</a>.</p>
</div>
<div class="section" id="example-2">
<a class="toc-backref" href="#id23">Example 2</a>
<p>As another example consider:</p>
<pre class="literal-block">
class A(object):

    def f(self, p1, p2):
        print p1
        print p2


a = A()
a.f(1, 2)
</pre>
<p>Later we decide that <cite>A.f()</cite> is doing too much and we want to divide
it to <cite>A.f1()</cite> and <cite>A.f2()</cite>:</p>
<pre class="literal-block">
class A(object):

    def f(self, p1, p2):
        print p1
        print p2

    def f1(self, p):
        print p

    def f2(self, p):
        print p


a = A()
a.f(1, 2)
</pre>
<p>But who's going to fix all those nasty occurrences (actually this
situation can be handled using inline method refactoring but this is
just an example; consider inline refactoring is not implemented yet!).
Restructurings come to rescue:</p>
<pre class="literal-block">
pattern: ${inst}.f(${p1}, ${p2})
goal:
 ${inst}.f1(${p1})
 ${inst}.f2(${p2})

args:
 inst: type=mod.A
</pre>
<p>After performing we will have:</p>
<pre class="literal-block">
class A(object):

    def f(self, p1, p2):
        print p1
        print p2

    def f1(self, p):
        print p

    def f2(self, p):
        print p


a = A()
a.f1(1)
a.f2(2)
</pre>
</div>
<div class="section" id="example-3">
<a class="toc-backref" href="#id24">Example 3</a>
<p>If you like to replace every occurrences of <tt class="docutils literal"><span class="pre">x.set(y)</span></tt> with <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span>
<span class="pre">y</span></tt> when x is an instance of <cite>mod.A</cite> in:</p>
<pre class="literal-block">
from mod import A

a = A()
b = A()
a.set(b)
</pre>
<p>We can perform a restructuring with these information:</p>
<pre class="literal-block">
pattern: ${x}.set(${y})
goal: ${x} = ${y}

args: x: type=mod.A
</pre>
<p>After performing the above restructuring we'll have:</p>
<pre class="literal-block">
from mod import A

a = A()
b = A()
a = b
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">mod.py</span></tt> contains something like:</p>
<pre class="literal-block">
class A(object):

    def set(self, arg):
        pass
</pre>
</div>
<div class="section" id="issues">
<a class="toc-backref" href="#id25">Issues</a>
<p>Pattern names can appear only at the start of an expression.  For
instance <tt class="docutils literal"><span class="pre">var.${name}</span></tt> is invalid.  These situations can usually be
fixed by specifying good checks, for example on the type of <cite>var</cite> and
using a <tt class="docutils literal"><span class="pre">${var}.name</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="object-inference">
<a class="toc-backref" href="#id26">Object Inference</a>
<p>This section is a bit out of date.  Static object inference can do
more than described here (see unittests).  Hope to update this
someday!</p>
<div class="section" id="static-object-inference">
<a class="toc-backref" href="#id27">Static Object Inference</a>
<pre class="literal-block">
class AClass(object):

    def __init__(self):
        self.an_attr = 1

    def call_a_func(self):
        return a_func()

def a_func():
    return AClass()

a_var = a_func()
#a_var.${codeassist}

another_var = a_var
#another_var.${codeassist}
#another_var.call_a_func().${codeassist}
</pre>
<p>Basic support for builtin types:</p>
<pre class="literal-block">
a_list = [AClass(), AClass()]
for x in a_list:
    pass
    #x.${codeassist}
#a_list.pop().${codeassist}

a_dict = ['text': AClass()]
for key, value in a_dict.items():
    pass
    #key.${codeassist}
    #value.${codeassist}
</pre>
<p>Enhanced static returned object inference:</p>
<pre class="literal-block">
class C(object):

    def c_func(self):
        return ['']

def a_func(arg):
    return arg.c_func()

a_var = a_func(C())
</pre>
<p>Here rope knows that the type of a_var is a <cite>list</cite> that holds <cite>str</cite>s.</p>
<p>Supporting generator functions:</p>
<pre class="literal-block">
class C(object):
    pass

def a_generator():
    yield C()


for c in a_generator():
    a_var = c
</pre>
<p>Here the objects <cite>a_var</cite> and <cite>c</cite> hold are known.</p>
<p>Rope collects different types of data during SOA, like per name data
for builtin container types:</p>
<pre class="literal-block">
l1 = [C()]
var1 = l1.pop()

l2 = []
l2.append(C())
var2 = l2.pop()
</pre>
<p>Here rope can easily infer the type of <cite>var1</cite>.  But for knowing the
type of <cite>var2</cite>, it needs to analyze the items inserted into <cite>l2</cite> which
might happen in other modules.  Rope can do that by running SOA on
that module.</p>
<p>You might be wondering is there any reason for using DOA instead of
SOA.  The answer is that DOA might be more accurate and handles
complex and dynamic situations.  For example in:</p>
<pre class="literal-block">
def f(arg):
    return eval(arg)

a_var = f('C')
</pre>
<p>SOA can no way conclude the object <cite>a_var</cite> holds but it is really
trivial for DOA.  What's more SOA only analyzes calls in one module
while DOA analyzes any call that happens when running a module.  That
is, for achieving the same result as DOA you might need to run SOA on
more than one module and more than once (not considering dynamic
situations.) One advantage of SOA is that it is much faster than DOA.</p>
</div>
<div class="section" id="dynamic-object-analysis">
<a class="toc-backref" href="#id28">Dynamic Object Analysis</a>
<p><cite>PyCore.run_module()</cite> runs a module and collects object information if
<tt class="docutils literal"><span class="pre">perform_doa</span></tt> project config is set.  Since as the program runs rope
gathers type information, the program runs much slower.  After the
program is run, you can get better code assists and some of the
refactorings perform much better.</p>
<p><tt class="docutils literal"><span class="pre">mod1.py</span></tt>:</p>
<pre class="literal-block">
def f1(param):
    pass
    #param.${codeassist}
    #f2(param).${codeassist}

def f2(param):
    #param.${codeassist}
    return param
</pre>
<p>Using code assist in specified places does not give any information
and there is actually no information about the return type of <cite>f2</cite> or
<cite>param</cite> parameter of <cite>f1</cite>.</p>
<p><tt class="docutils literal"><span class="pre">mod2.py</span></tt>:</p>
<pre class="literal-block">
import mod1

class A(object):

    def a_method(self):
        pass

a_var = A()
mod1.f1(a_var)
</pre>
<p>Retry those code assists after performing DOA on <cite>mod2</cite> module.</p>
<div class="section" id="builtin-container-types">
<a class="toc-backref" href="#id29">Builtin Container Types</a>
<p>Builtin types can be handled in a limited way, too:</p>
<pre class="literal-block">
class A(object):

    def a_method(self):
        pass

def f1():
    result = []
    result.append(A())
    return result

returned = f()
#returned[0].${codeassist}
</pre>
<p>Test the the proposed completions after running this module.</p>
</div>
</div>
<div class="section" id="guessing-function-returned-value-based-on-parameters">
<a class="toc-backref" href="#id30">Guessing Function Returned Value Based On Parameters</a>
<p><tt class="docutils literal"><span class="pre">mod1.py</span></tt>:</p>
<pre class="literal-block">
class C1(object):

    def c1_func(self):
        pass

class C2(object):

    def c2_func(self):
        pass


def func(arg):
    if isinstance(arg, C1):
        return C2()
    else:
        return C1()

func(C1())
func(C2())
</pre>
<p>After running <cite>mod1</cite> either SOA or DOA on this module you can test:</p>
<p><tt class="docutils literal"><span class="pre">mod2.py</span></tt>:</p>
<pre class="literal-block">
import mod1

arg = mod1.C1()
a_var = mod1.func(arg)
a_var.${codeassist}
mod1.func(mod1.C2()).${codeassist}
</pre>
</div>
<div class="section" id="automatic-soa">
<a class="toc-backref" href="#id31">Automatic SOA</a>
<p>When turned on, it analyzes the changed scopes of a file when saving
for obtaining object information; So this might make saving files a
bit more time consuming.  By default, this feature is turned on, but
you can turn it off by editing your project <tt class="docutils literal"><span class="pre">config.py</span></tt> file, though
that is not recommended.</p>
</div>
<div class="section" id="validating-object-db">
<a class="toc-backref" href="#id32">Validating Object DB</a>
<p>Since files on disk change over time project objectdb might hold
invalid information.  Currently there is a basic incremental objectdb
validation that can be used to remove or fix out of date information.
Rope uses this feature by default but you can disable it by editing
<tt class="docutils literal"><span class="pre">config.py</span></tt>.</p>
</div>
</div>
<div class="section" id="custom-source-folders">
<a class="toc-backref" href="#id33">Custom Source Folders</a>
<p>By default rope searches the project for finding source folders
(folders that should be searched for finding modules).  You can add
paths to that list using <tt class="docutils literal"><span class="pre">source_folders</span></tt> project config.  Note that
rope guesses project source folders correctly most of the time.  You
can also extend python path using <tt class="docutils literal"><span class="pre">python_path</span></tt> config.</p>
</div>
<div class="section" id="version-control-systems-support">
<a class="toc-backref" href="#id34">Version Control Systems Support</a>
<p>When you perform refactorings some files might need to be moved (when
renaming a module) or new files might be created.  When you use a VCS
rope uses that to perform file system actions.</p>
<p>Currently rope supports Subversion (Uses <a class="reference external" href="http://pysvn.tigris.org">pysvn</a> library) and
<a class="reference external" href="http://selenic.com/mercurial">Mercurial</a>.  Rope uses Subversion if the <cite>pysvn</cite> module is available
and there is a <cite>.svn</cite> in project root.  The Mercurial will be used if
<cite>mercurial</cite> module is available and there is a <cite>.hg</cite> in project root.
Rope assumes either all files are under version control in a project
or there is no version control at all.  Also don't forget to commit
your changes yourself, rope doesn't do that.</p>
<p>Adding support for other VCSs is easy; have a look at
<a class="reference external" href="library.html">library.txt</a>.</p>
</div>
</div>
</body>
</html>
